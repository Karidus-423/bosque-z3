#include <stdlib.h>
#include <string>

const char *c_string_smt =
    ";;\n"
    ";;Template file for building SMTLIB models of Bosque code\n"
    ";;\n"
    "\n"
    "(declare-datatype @Result (par (T) (\n"
    "    (@Result-err-trgt)\n"
    "    (@Result-err-other)\n"
    "    (@Result-ok (@Result-value T))\n"
    ")))\n"
    "\n"
    "(declare-datatypes (\n"
    "    (@EList-2 2)\n"
    "    (@EList-3 3)\n"
    "    (@EList-4 4)\n"
    "    ) (\n"
    "        (par (T1 T2) ((@EList-2-mk (_1 T1) (_2 T2))) )\n"
    "        (par (T1 T2 T3) ((@EList-3-mk (_1 T1) (_2 T2) (_3 T3))) )\n"
    "        (par (T1 T2 T3 T4) ((@EList-4-mk (_1 T1) (_2 T2) (_3 T3) (_4 "
    "T4))) )\n"
    "    )\n"
    ")\n"
    "\n"
    ";;\n"
    ";; Primitive datatypes \n"
    ";;\n"
    "(declare-datatype None ((none)))\n"
    ";;Bool is Bool\n"
    "(define-sort Nat () Int)\n"
    ";;Int is Int\n"
    "(define-sort BigNat () Int)\n"
    "(define-sort BigInt () Int)\n"
    "(define-sort Float () Real)\n"
    "(define-sort CString () String)\n"
    ";;String is String\n"
    "\n"
    ";;no content -- ;;--ENUM_DECLS--;;\n"
    ";;no content -- ;;--TYPEDECL_DECLS--;;\n"
    "\n"
    ";;\n"
    ";; Entity datatypes \n"
    ";;\n"
    "(declare-datatypes (\n"
    "    ;;no content -- ;;--SPECIAL_DECLS--;;\n"
    "    ;;no content -- ;;--COLLECTION_DECLS--;;\n"
    "    ;;no content -- ;;--ENTITY_DECLS--;;\n"
    "    ;;no content -- ;;--DATATYPE_DECLS--;;\n"
    "    (@Term 0)\n"
    "    ) (\n"
    "        ;;no content -- ;;--SPECIAL_CONSTRUCTORS--;;\n"
    "        ;;no content -- ;;--COLLECTION_CONSTRUCTORS--;;\n"
    "        ;;no content -- ;;--ENTITY_CONSTRUCTORS--;;\n"
    "        ;;no content -- ;;--DATATYPE_CONSTRUCTORS--;;\n"
    "        (\n"
    "            (@Term-mk-None)\n"
    "            ;;no content -- ;;--TYPEDECL_TERM_CONSTRUCTORS--;;\n"
    "            ;;no content -- ;;--SPECIAL_TERM_CONSTRUCTORS--;;\n"
    "            ;;no content -- ;;--ENTITY_TERM_CONSTRUCTORS--;;\n"
    "            ;;no content -- ;;--DATATYPE_TERM_CONSTRUCTORS--;;\n"
    "        )\n"
    "    )\n"
    ")\n"
    "\n"
    ";;no content -- ;;--SUBTYPE_PREDICATES--;;\n"
    "\n"
    ";;NLA options\n"
    "(declare-fun @NLA_I_mult (Int Int) Int)\n"
    "(declare-fun @NLA_I_div (Int Int) Int)\n"
    "\n"
    "(declare-const Main@s CString) (declare-const Main@s-cc-temp (@Result "
    "CString))\n"
    "\n"
    ";;no content -- ;;--PRE_FUNCS--;;\n"
    "\n"
    "(define-fun Main@main ((s CString)) (@Result CString)\n"
    "    (let ((t \"Manchester\"))\n"
    "        (ite (not (not (= s t))) (as @Result-err-other (@Result "
    "CString))\n"
    "            (@Result-ok t)\n"
    "        )\n"
    "    )\n"
    ")\n"
    "\n"
    "(assert (= Main@s-cc-temp (@Result-ok \"Manchester\")))\n"
    "(assert (is-@Result-ok Main@s-cc-temp))\n"
    "(assert (= Main@s (@Result-value Main@s-cc-temp)))\n"
    ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
    ";; Seems to work without buttom statements.\n"
    ";;(declare-const a_str String)\n"
    ";;(declare-const res (@Result String))\n"
    ";;(assert (= res (Main@main a_str)))\n"
    ";;(assert (= res @Result-err-other))\n";

const char *data_type_smt =
    ";;Template file for building SMTLIB models of Bosque code\n"
    "\n"
    "(declare-datatype @Result (par (T) (\n"
    "    (@Result-err-trgt)\n"
    "    (@Result-err-other) \n"
    "    (@Result-ok (@Result-value T))\n"
    ")))\n"
    "\n"
    ";;\n"
    ";; Primitive datatypes \n"
    ";;\n"
    "(declare-datatype None ((none)))\n"
    ";;Bool is Bool\n"
    "(define-sort Nat () Int)\n"
    ";;Int is Int\n"
    "(define-sort BigNat () Int)\n"
    "(define-sort BigInt () Int)\n"
    "(define-sort Float () Real)\n"
    "(define-sort CString () String)\n"
    ";;String is String\n"
    "\n"
    ";;no content -- ;;--ENUM_DECLS--;;\n"
    ";;no content -- ;;--TYPEDECL_DECLS--;;\n"
    "\n"
    ";;\n"
    ";; Entity datatypes \n"
    ";;\n"
    "(declare-datatypes (\n"
    "    ;;no content -- ;;--SPECIAL_DECLS--;;\n"
    "    ;;no content -- ;;--COLLECTION_DECLS--;;\n"
    "    (Main@Foo 0)\n"
    "    ;;no content -- ;;--DATATYPE_DECLS--;;\n"
    "    (@Term 0)\n"
    "    ) (\n"
    "        ;;no content -- ;;--SPECIAL_CONSTRUCTORS--;;\n"
    "        ;;no content -- ;;--COLLECTION_CONSTRUCTORS--;;\n"
    "        ((Main@Foo-mk (Main@Foo-x Int) (Main@Foo-y Int)))\n"
    "        ;;no content -- ;;--DATATYPE_CONSTRUCTORS--;;\n"
    "        (\n"
    "            (@Term-mk-None)\n"
    "            ;;no content -- ;;--TYPEDECL_TERM_CONSTRUCTORS--;;\n"
    "            ;;no content -- ;;--SPECIAL_TERM_CONSTRUCTORS--;;\n"
    "            ;;no content -- ;;--ENTITY_TERM_CONSTRUCTORS--;;\n"
    "            ;;no content -- ;;--DATATYPE_TERM_CONSTRUCTORS--;;\n"
    "        )\n"
    "    )\n"
    ")\n"
    "\n"
    ";;no content -- ;;--SUBTYPE_PREDICATES--;;\n"
    "\n"
    ";;NLA options\n"
    "(declare-fun @NLA_I_mult (Int Int) Int)\n"
    "(declare-fun @NLA_I_div (Int Int) Int)\n"
    "\n"
    "(declare-const Int@zero Int) (declare-const Int@zero-cc-temp (@Result "
    "Int))\n"
    "(declare-const Int@one Int) (declare-const Int@one-cc-temp (@Result "
    "Int))\n"
    "\n"
    ";;no content -- ;;--PRE_FUNCS--;;\n"
    "\n"
    "(define-fun Main@main ((f Main@Foo)) (@Result Int)\n"
    "    (let ((k (+ (Main@Foo-x f) (Main@Foo-y f))))\n"
    "        (ite (not (> k (Main@Foo-x f))) (as @Result-err-other (@Result "
    "Int))\n"
    "            (@Result-ok k)\n"
    "        )\n"
    "    )\n"
    ")\n"
    "\n"
    "(assert (= Int@zero-cc-temp (@Result-ok 0)))\n"
    "(assert ((_ is @Result-ok) Int@zero-cc-temp))\n"
    "(assert (= Int@zero (@Result-value Int@zero-cc-temp)))\n"
    "(assert (= Int@one-cc-temp (@Result-ok 1)))\n"
    "(assert ((_ is @Result-ok) Int@one-cc-temp))\n"
    "(assert (= Int@one (@Result-value Int@one-cc-temp)))\n"
    "\n"
    ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
    ";;Above is SMTLIB code generated from the Bosque Code\n"
    ";;Below is the setup for checking for an error -- if we can trigger \n"
    ";;then error then the entire formula is satisfiable and we want get the "
    "value \n"
    ";;for the argument \"f\"\n"
    "\n"
    "(declare-const f Main@Foo)\n"
    "(declare-const res (@Result Int))\n"
    "(assert (= res (Main@main f)))\n"
    "\n"
    "(assert (= res @Result-err-other))\n"
    "\n"
    "(check-sat)\n"
    "(get-model)\n";
;
